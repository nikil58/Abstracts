# C++ с низкой задержкой для удовольствия и выгоды
## О чем данный конспект?

Данный коспект содержит информацию о различных трюках и техниках оптимизации внутри С++, которые дают определнный прирост в производительности программ на C++. Все это необходимо для своевременной реакции на различные события внутри биржи: отслеживать первее всех выгодные предложения, а также продавать то, у чего кончается срок действия.

[Ссылка на видеолекцию](https://www.youtube.com/watch?v=BxfT9fiUsZ4)



## Конспект
Скорость исполнения программы во многом зависит от железа: процессора, памяти и др. Однако, мы будем рассматривать только то, с чем разработчик может непосредственно взаимодействовать:
+ Компилятор (и его версия)
+ Архитектура ПК
+ Сторонние библиотеки
+ Сборка и флаги линковки

Для всего этого необходимо понимать, что делает С++ с точки зрения машины, т.е. изучить ассемблер. К счастью, существуют готовые [решения](https://godbolt.org/). Но об этом позже.
Сейчас разговор пойдет о методах программирования с малой задержкой.

Перед началом разговора нужно понимать то, что оптимизировать мы будем "критический участок" кода. Это тот самый участок кода (обычно небольшого размера), который **должен** быть быстрым, иначе Вы потеряете деньги (обработка, отправка запросов и т.п.).

Но что значит "быть быстрым"? 

### Методы программирования с малой задержкой
+ #### Избавление от длинных (медленных) веток
Необходимо избегать заведомо более длинных решений, если есть более простое. Например, есть участок кода, который либо выполняет что-то, либо выбрасывает исключение. И в зависимости от исключения, будет разная обработка ошибки. Можно в этом же участке кода проверять на исключение "A" и если оно выбросилось, обработать его. Проверить на исключение "B", и также обработать его, если это необходимо, и т.д. Но фактически нас интересует следующий результат: если **ЛЮБОЙ** ошибки нет, то выполнить что-то, иначе -- не выполнять. Так вот в этом участке кода нам нет необходимости узнавать, какое конкретное исключение было выброшено. Если что-то выбросилось, то переадресовать это в обработчик ошибок и там уже определить, что за ошибка и как ее обработать. 

**Отказаться от:**
```cpp
if (checkForErrorA())
 handleErrorA();
else if (checkForErrorB())
 handleErrorB();
else if (checkForErrorC())
 handleErrorC();
else
 sendOrderToExchange();
```
**Использовать:**
```cpp
int64_t errorFlags;
 ...
if (!errorFlags)
 sendOrderToExchange();
else
 HandleError(errorFlags);
```
_P.S. 32-битные переменные гораздо проще проверяются на равенство 0_

+ #### Избавление от виртуальных функций
Виртуальные функции слишком дорогие, чтобы их использовать, когда хочется управлять чем-то с помощью файла конфигурации. Однако, вместо этого лучше использовать шаблоны (STL), они помогут убрать код, который не будет использоваться. 

**Использовать**
```cpp
//1st implementation
struct OrderSenderA {
 void SendOrder() { 
 ...
 }
};
```
```cpp
//2nd implementation
struct OrderSenderB {
 void SendOrder() {
 ...
 } 
};
```
```cpp
template <typename T>
struct OrderManager : public IOrderManager {
 void MainLoop() final {
 // ... and at some stage in the future...
 mOrderSender.SendOrder();
 }
 T mOrderSender;
};
std::unique_ptr<IOrderManager> Factory(const Config& config) {
 if (config.UseOrderSenderA())
  return std::make_unique<OrderManager<OrderSenderA>>();
 else if (config.UseOrderSenderB())
  return std::make_unique<OrderManager<OrderSenderB>>();
 else
  throw;
}
int main(int argc, char *argv[]) {
 auto manager = Factory(config);
 manager->MainLoop();
}
```
_P.S. Виртуальные функции необходимо использовать тогда, когда неизвестно какой тип данных ожидается_

+ #### Использование памяти
По возможности, нужно избегать использования слов **new** и **delete**, т.к. они тянут за собой множество строк кода. Вместо этого можно использовать уже расположенные в памяти объекты, а также переиспользование объектов, вместо удаления. Если все же необходимо удалить какой-то большой объект, то лучше это сделать где-то снаружи "критической секции", в другом потоке. Также не стоит забывать о фрагментации памяти.

  _P.S. Необходимо помнить, что некоторые объекты имеют встроенные деструкторы, что может привести к перегрузке кэша инструкций_
  
+ #### Исключения (на gcc, clang, msvc)
Не стоит бояться использовать исключения. Их наличие в коде не слишком замедляет программу, а если исключение выбросилось, то никакой речи о скорости и быть не может (Необходимо записать лог, дамп ядра, выключение). 

 _P.S. Не стоит использовать исключения для потока управления_
 
+ #### Уменьшение логических веток
Не стоит использовать конструкции if-else для участка кода, в котором возможно различное поведение в зависимости от условия (Так называемый, ветвистый участок кода). Не стоит использовать if-else конструкции в своем критическом участке кода. Использовать их где-либо еще - нормально. Но не в критической секции. Что можно использовать вместо этого? Шаблоны. Это ускорит время компиляции, а также даст достаточно большой прирост вашей программею: 

  **Избегать**
  ```cpp
  enum class Side { Buy, Sell };
  void RunLogic(Side side) {
    const float orderPrice = CalcPrice(side, fairValue, credit);
    CheckRiskLimits(side, orderPrice);
    SendOrder(side, orderPrice);
   }
  float CalcPrice(Side side, float value, float credit) {
    return side == Side::Buy ? value - credit : value + credit;
   }
  ```
  **Использовать**
  ```cpp
   template<>
   void RunLogic<Side::Buy>() {
     float orderPrice = CalcPrice<Side::Buy>(fairValue, credit);
     CheckRiskLimits<Side::Buy>(orderPrice);
     SendOrder<Side::Buy>(orderPrice);
   }
   template<>
     float CalcPrice<Side::Buy>(float value, float credit) {
     return value - credit;
   }
   template<>
     float CalcPrice<Side::Sell>(float value, float credit) {
     return value + credit;
   }
  ```
  
+ #### Многопоточность
По возможности избегайте многопоточности в "критических секциях" кода. Для этого есть ряд причин:
  1. Синхронизация с помощью прерываний - дорого. 
  2. Блокировка свободного участка кода может требовать блокировки на уровне железа. 
  3. Сложный параллелизм. 

Если избежать многопоточности невозможно, то нужно придерживаться следующих правил:
  1. Общие данные (Shared Data) должны быть минимальны.
  2. Нужно использовать копии данных, а не сами данные для обмена.
  3. По возможности отказаться от синхронизации (возможно, синхронизация не необходима, или архитектура машины предотвращает прерывания чтения/записи).
  
+ #### Поиск данных
Мы привыкли связывать данные по id, по ключевым полям, чтобы все данные были нормализованы. Однако, если вы хотите достигнуть большей производительности, денормализованные данные использовать можно. В частности, на примерах становится понятно, как использовать денормализованные данные:

  **Избегать:**
  ```cpp
  struct Market {
   int32_t id;
   char shortName[4];
   int16_t quantityMultiplier;
   ...
   }
  struct Instrument {
   float price;
   int32_t marketId;
   ...
  }
  Message orderMessage;
  orderMessage.price = instrument.price;
  Market& market = Markets.FindMarket(instrument.marketId);
  orderMessage.qty = market.quantityMultiplier * qty;
   ...
  ```
  
  **Использовать:**
  ```cpp
  struct Market {
   int32_t id;
   char shortName[4];
   int16_t quantityMultiplier;
   ...
   }
  struct Instrument {
   float price;
   int16_t quantityMultiplier;
   ...
  }
  ```
  
+ #### Ассоциативные контейнеры
Одним из самых быстрых решений в данной области является unordered_map. Однако, его использование лишь относительно быстро. Вся технология такого контейнера фактически заключается в однонаправленном связном списке. В лучшем случае, каждая пара ключ-значение единственна в своем блоке (bucket). Но так происходит не всегда. Поэтому иногда для поиска нужного значения приходится просматривать кучу ненужных ключей. Есть более быстрый подход: гугловская dense_hash_map. Она быстрее, потому что пары ключ-значение находятся в непрерывном участке памяти, а значит нет указателей между узлами. Минус такого подхода: сложность разрешения коллизий. Дабы лишить этого подхода минусов можно комбинировать оба способа. Это позволит использовать минимальный объем памяти, а также без прыжков искать нужную информацию внутри кэша. 

+ #### Подсказки likely и unlikely
Такие подсказки можно и нужно использовать тогда, когда мы хотим дать понять комплиятору о том, что какой-то из исходов if-else нам больше подходит, чем другой. Для использования необходимо их (подсказки) определить: 
```cpp
#define likely(x) __builtin_expect((x),1)
#define unlikely(x) __builtin_expect((x),0)
```
Давайте посмотрим, что будет видеть компилятор GCC без этих подсказок для следующего участка кода:
```cpp
int GetErrorCode() {
 return rand() % 255 + 1;
}
int main(int argc, char**) {
 if (argc > 1)
 return GetErrorCode();
 else
 return 0;
}
```
На ассмблере это будет выглядеть так:
```assembly
main:
 cmp edi, 1 // argc
 jle .L7
 sub rsp, 8
 call rand
 mov ecx, 255
 cdq
 idiv ecx
 lea eax, [rdx+1]
 pop rdx
 ret
.L7:
 xor eax, eax // zeros ebx
 ret
 ```
 
 Если же мы вставим подсказки компилятору:
 ```cpp
int GetErrorCode() {
 return rand() % 255 + 1;
}
int main(int argc, char**) {
  if (unlikely(argc > 1))
  return GetErrorCode();
  else
  return 0;
}
```
То ассемблеровский код будет выглядеть следующим образом:
```assembly
main:
 cmp edi, 1
 jg .L12
 xor eax, eax
 ret
.L12:
 sub rsp, 8
 call rand
 mov ecx, 255
 cdq
 idiv ecx
 lea eax, [rdx+1]
 pop rdx
 ret
 ```
 Как мы видим, теперь ветка main гораздо короче. Использовать подобные подсказки выгодно, когда что-то вызывается очень редко (из-за какой-то ошибки).
 
+ #### Атрибуты компилятора
  Существует ряд полезных атрибутов для компилятора, которые могут ускорить работу (однако, нужно быть с ними осторожными, они могут также и замедлить работу). Рассмотрим некоторые из них:
  + ##### ((always_inline)) и ((noinline))
    Позволяет определить, что более предпочтительно: вставить или прыгнуть в определенную область с ассемблеровским кодом. Например:
    ```cpp
      void get_error_code() { ... }
      int main(int argc, char**) {
       if (argc > 1)
       return get_error_code();
       else
       return 0;
      }
    ```
    На ассмеблере будет так:
    ```assembly
    get_error_code:
     ...
     ret
    main:
     cmp edi, 1 // argc register
     jle .L6
     jmp get_error_code
    .L6:
     xor eax, eax // zeros eax
     ret // eax is the ret val
    ```
    Если хотим все же встроить в участок кода:
    ```cpp
    __attribute__((always_inline))
    void get_error_code() { ... }
    int main(int argc, char**) {
     if (argc > 1)
     return get_error_code();
     else
     return 0;
    }
    ```
    Ассемблер:
    ```assembly
    main:
      cmp edi, 1
      jle .L6
      get_error_code instruction 1
      get_error_code instruction ..
      get_error_code instruction N
      mov eax, [error code]
      ret
    .L6:
      xor ebx, ebx // zeros ebx
      ret
    ```
    Также можно комбинировать эти атрибуты с подсказками:
    ```cpp
    __attribute__((noinline))
    void get_error_code() { ... }
    int main(int argc, char**) {
     if (unlikely(argc > 1))
     return get_error_code();
     else
     return 0;
    }
    ```
    Ассемблер:
    ```assembly
    get_error_code:
    ...
    ret
    main:
     cmp edi, 1
     jg .L7
     xor eax, eax
     ret
    .L7:
     jmp get_error_code
    ```
   + ##### __attribute__((hot)) и __attribute__((cold))
     Выполняет то же самое, что и ((always_inline)) и ((noinline)).
   + ##### __builtin_prefetch
     Также может помочь в случае, если вы знаете, что ветка-предсказатель не сможет определить правильную закономерность:
      ```cpp
     // next mid val after this iteration if we take the low path
      __builtin_prefetch(&array[(low + mid - 1)/2]);
     // next mid val after this iteration if we take the high path
      __builtin_prefetch(&array[(mid + 1 + high)/2]);
      int mid = (low + high) / 2;
      if (array[mid] == key) return mid;
      if (array[mid] < key) low = mid + 1; // search high path
      else high = mid - 1; // search low path
       ```
  
+ #### Горячий кэш
Пожалуй, самый наилучший способ ускорения работы вашего приложения. Так бывает, что ваша программа (в частности, критическая секция) какое-то длительное время ничем не занимается: нет подходящего ценника, предложения и т.п. В таком случае кэш засоряется другими инструкциями и для выгрузки/загрузки данных потребуется какое-то время. Для решения этой проблемы достаточно "обмануть" критическую секцию. "Сказать" ей, чтобы она работала. При этом будет сохраняться кэш данных и кэш инструкций. Необходимо и достаточно время от времени запускать код критической секции, даже если в этом не было необходимости. 

+ #### Строки
В общем говоря, нужно стараться избегать строк с использованием ключевого слова "string", потому что иногда не нужен весь интерфейс string, а также другие проблемы, связанные с аллоцированием и др. Самым лучшим решением будет использование std::string_view или других API для работы со строками:
  ```cpp
    std::map<std::string, Instrument, std::less<>> instruments;
    instruments.find(std::string_view{"FACEBOOK"})->second;

    std::string name{"FACEBOOK"};
    instruments.find(name.substr(1,3)); // "ACE"
```
_P.S. В стандартах C++17 и C++14 доступно под названием std::experimental::string_view_

+ #### Использование Switch и Enum
Вы, наверное,  помните, что компилятор очень хорош в операциях сравнения на равенство/неравенство нулю. Так вот, это стоит учитывать при использовании Switch. Если есть кейс, в который вы чаще всего будете и должны попадать, то его стоит сделать первым (нулевым):
  ```cpp
    enum Enum { Good, Bad, Ugly };
    int main(int argc, char**) {
     switch ((Enum)argc) {
     case Good: Handle("GOOD");
    break;
     case Bad: Handle("BAD");
    break;
     case Ugly: Handle("UGLY");
    break;
     }
    }
  ```
  На ассемблере:
  ```assebmly
    main:
   sub rsp, 8
   test edi, edi
   je .L8
   cmp edi, 1
   je .L3
   cmp edi, 2
   je .L4
  ```
  Как вы можете видеть, для первой проверки компилятор решил использовать другую инструкцию: test. 
  
+ #### Математика
Стоит очень осторожно использовать различные математические функции в GlibC, потому что они могут работать по-странному медленно:
  ```cpp
  auto base = 1.00000000000001, exp1 = 1.4, exp2 = 1.5;
  std::pow(base, exp1) = 1.0000000000000140
  std::pow(base, exp2) = 1.0000000000000151
  ```
  Первое возведение в степень работает за 53 наносекунды, второе - за 478195 наносекунды. Стоит следить за обновлениями библиотеки для избегания подобных проблем. 
## Заключение
Для того, чтобы Ваши "критические секции" были достаточно производительны, чтобы не ставить под удар вашу прибыль, необходимо уметь писать максимально оптимизированный код. Для этого:
+ Хорошо знать не только C++, но и компилятор
+ Знать архитектуру машины и то, как она может влиять на Вашу программу
+ Делать как можно больше полезной работы во время компиляции
+ Стараться сделать "критическую секцию" логически простой
+ Следить за обновлением железа, библиотек, компилятора и т.п.

Спасибо за внимание!
